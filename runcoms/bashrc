#!/bin/bash -e

if [ -z "$PS1" ]; then
  return
fi

if [ "bash" != "${0}" ] && [ "/bin/bash" != "${0}" ]; then
  1>&2 echo "Denied: Script cannot be invoked on the command line"
  exit 1
fi
set -o braceexpand
set -o notify
set -o hashall
set -o histexpand
set -o monitor
set -o physical
set -o emacs

shopt -u cdable_vars
shopt -s cdspell
shopt -u checkhash
shopt -s checkwinsize
shopt -s cmdhist
shopt -s dotglob
shopt -u execfail
shopt -s expand_aliases
shopt -s extglob
shopt -s histappend
shopt -s histreedit
shopt -s histverify
shopt -u hostcomplete
shopt -u huponexit
shopt -s interactive_comments
shopt -u lithist
shopt -s no_empty_cmd_completion
shopt -u nocaseglob
shopt -u nullglob
shopt -s progcomp
shopt -s promptvars
shopt -u shift_verbose
shopt -u sourcepath
shopt -s xpg_echo

export EDITOR=vim
export FCEDIT=vi
export FIGNORE=.o:~:.swp
export GLOBIGNORE="*.swp"
export HISTCONTROL=ignoreboth
export HISTFILE="$HOME/.bash_history/"
export HISTFILESIZE=2000
export HISTIGNORE='fg:cd *:l:ls:ll:la:gst:cdl *'
export HISTSIZE=1000
export HISTTIMEFORMAT="[%m/%d] [%T]   "
export PAGER=less
export PROMPT_DIRTRIM=3
export TIMEFORMAT=$'\nreal %3R\tuser %3U\tsys %3S\tpcpu %P\n'
export TMOUT=0
export PATH="$PATH:${HOME}/.local/bin:${HOME}/dev/bin"

#
# Security
#
umask u=rwx,g=,o=

# see lesspipe(1)
if [ -x /usr/bin/lesspipe ]; then
  eval "$(SHELL=/bin/sh lesspipe)"
fi

#
# Solarized terminal dircolors
#
case "$TERM" in
    xterm-color|*-256color) eval "$(dircolors "$HOME/.dir_colors/dircolors")"
esac
case "$TERM" in
    xterm-color|*-256color) color_prompt=yes;;
esac

set_bash_prompt() {
  local -r BLK_BG="\[$(tput setab 0)\]"
  local -r RED="\[$(tput setaf 1)\]"
  local -r GRN="\[$(tput setaf 2)\]"
  local -r CYN="\[$(tput setaf 6)\]"
  local -r WHT="\[$(tput setaf 7)\]"
  local -r BLD="\[$(tput bold)\]"
  local -r CLR="\[$(tput sgr0)\]"

  local len="$(($(tput cols) - 4))" # personal preference on spacing

  local -r header="${WHT}┌$( printf "%${len}s" | sed 's/ /─/g')┐${CLR}"
  local -r time_stat=" ${RED}${BLD}${BLK_BG}\@${CLR} "
  local -r jobs_stat="${GRN}${BLD}$(printf " & \j ")${CLR}"
  local -r dir_stat=" ${GRN}${BLD}\w ${CLR}"
  local -r exit_stat="$( \
    if [ "$1" = "0" ]; then \
      printf "%s%8s%s " "${GRN}${BLD}" '✓  ' "${CLR}"; \
    else \
      printf "%s%8s%s " "${RED}${BLD}" "⚠ ${1}" "${CLR}"; \
    fi )"
  local -r git_status="${WHT}┕${CYN}${BLD} $(git branch 2>/dev/null | grep '^\*' | colrm 1 2) ${CLR}"

  PS1="$( printf "%s%s%s%s%s\n%s\$ " \
    "\n${header}\r" \
    "$(tput cuf 3)${time_stat}" \
    "$(tput cuf 2)${exit_stat}" \
    "$(tput cuf 2)${jobs_stat}" \
    "$(tput cuf 2)${dir_stat}" \
    "${git_status}"
  )"
}

if [ "$color_prompt" = 'yes' ]; then
  export GCC_COLORS='error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01'
  PROMPT_COMMAND='set_bash_prompt $?'
else
  if [ -z "${debian_chroot:-}" ] && [ -r '/etc/debian_chroot' ]; then
    debian_chroot="$(cat /etc/debian_chroot)"
  fi

  PS1='${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '
  case "$TERM" in
    xterm*|rxvt*)
        PS1="\[\e]0;${debian_chroot:+($debian_chroot)}\u@\h: \w\a\]$PS1"
        ;;
    *) ;;
  esac
fi

unset color_prompt debian_chroot
# System utils
alias       ram='free -m -l -t'
alias    reboot='sudo /sbin/reboot'
alias  poweroff='sudo /sbin/poweroff'
alias  shutdown='sudo /sbin/shutdown'

alias          diff='command diff -W $(( $(tput cols) - 2 ))'
alias partition-use='df -hlT --exclude-type=tmpfs --exclude-type=devtmpfs'
alias         flush='sync'

# More verbose commands
alias chmod='chmod -v'
alias    mv='mv -v'
alias    cp='cp -v'

# Corrective aliases
alias cd..='cd ..'
alias sl='l'
alias bim=vim
alias cim=vim

# Tools
alias path='printf "${PATH//:/\\n}\n"'
alias  now='date +"%T"'
alias tree="find . -print | sed -e 's;[^/]*/;|__;g;s;__|; |;g'"
alias   ff='find . -name'
alias bman='bash-man'
alias   vi='vim'
alias  svi='sudo vi'
alias svim='sudo vi'

#
# ls configuration
#
if [ -x /usr/bin/dircolors ]; then
    if [ -r "$HOME/.dir_colors/dircolors" ]; then
      eval "$(dircolors -b "$HOME/.dir_colors/dircolors")"
    fi

    alias ls='ls --color=auto'
    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
fi

alias  l='ls -C'            # force multiline output
alias la='ls -A'            # show hidden and regular files
alias ll='ls -l'            # long format

# Dev tools
alias todos="ag --nogroup '(TODO|FIX(ME)?)[: ]'"

alias gbr='git branch'
alias gst='git status'
alias gco='git checkout'

alias  ga="git add"
alias gcm="git commit -m"
alias  gf="git fetch"
alias  gm="git merge"

# Compiler tools
alias gcc='gcc -Wall -Wpedantic -Werror'
alias c3='clang++ --std=c++03 -Wall -Wpedantic'
alias c11='clang++ --std=c++11 -Wall -Wpedantic'
alias venv_learning="source \${HOME}/dev/virtual_envs/learning/bin/activate"

check_for_venv() {
  local -r cmd="${1}"
  shift
  local -r params="${*}"
  local fp_prefix

  if [ "${VIRTUAL_ENV}" = "" ]; then
    read -r -p "Warning: Using user-level pip library. Proceed? [y/Y] " -n 1
    tput cr
    tput el
    if [[ ! "$REPLY" =~ ^[Yy]$ ]]; then
        return 2
    fi

    fp_prefix='/usr/bin'
  else
    fp_prefix="${VIRTUAL_ENV}/bin"
  fi

  # necessary because some executables won't accept the empty string
  if [ "${params}" = '' ]; then
    "${fp_prefix}/${cmd}"
  else
    "${fp_prefix}/${cmd}" "${params}"
  fi
}

warnful_pip() {
  check_for_venv 'pip' "$@"
}

warnful_python() {
  check_for_venv 'python' "$@"
}

pip() {
  warnful_pip "$@"
}

python() {
  warnful_python "$@"
}

bash-man() {

  echo-stderr() {
    echo "$*" 1>&2
  }

  usage() {
    echo-stderr "Usage: bash-man [valid shell builtin]"
  }

  local cmd

  # ignore quoted whitespace
  cmd=$( tr -d "[:space:]" <<< "$1" )

  if [ $# -ne 1 ]; then
    usage
    return 1
  fi

  if 2>&1 type "${cmd}" | grep -q "is a shell builtin"; then
    help "${cmd}" | "${PAGER:-less}"
  else
    echo-stderr "Error: '${cmd}' is not a valid shell builtin"
  fi
}

cdl() {
  cd "$@"
  ls --color=auto
}

